package com.chaojishipin.sarrs.thirdparty;


import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.util.UUID;

import org.json.JSONException;
import org.json.JSONObject;

import com.chaojishipin.sarrs.utils.MD5Utils;
import com.tencent.mm.algorithm.Base64;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Environment;
import android.provider.MediaStore.Files;
import android.provider.Settings.Secure;
import android.telephony.TelephonyManager;

public class DeviceUuidFactory {
    protected static final String PREFS_FILE = "device_id.xml";
    protected static final String PREFS_MD5_CHK = "md5_chk";
    protected static final String PREFS_DEVICE_ID = "device_id";

    protected static UUID uuid;

    public DeviceUuidFactory(Context context) {

        if (uuid == null) {
            synchronized (DeviceUuidFactory.class) {
                if (uuid == null) {
                    final SharedPreferences prefs = context.getSharedPreferences(PREFS_FILE, 0);
                    final String id = prefs.getString(PREFS_DEVICE_ID, null);
                    final String md5_chk = prefs.getString(PREFS_MD5_CHK, null);
                    if (id != null && checkMD5(id, md5_chk)) {
                        // Use the ids previously computed and stored in the
                        // prefs file
                        uuid = UUID.fromString(id);

                    } else {

                        try {

                            final String androidId =
                                    Secure.getString(context.getContentResolver(),
                                            Secure.ANDROID_ID);
                            if (!"9774d56d682e549c".equals(androidId)) {
                                uuid = UUID.nameUUIDFromBytes(androidId.getBytes("utf8"));
                            } else {
                                final String deviceId =
                                        ((TelephonyManager) context
                                                .getSystemService(Context.TELEPHONY_SERVICE))
                                                .getDeviceId();
                                if (null != deviceId) {
                                    uuid = UUID.nameUUIDFromBytes(deviceId.getBytes("utf8"));
                                }

                            }
                            if (null == uuid) {
                                uuid = UUID.randomUUID();
                            }
                        } catch (UnsupportedEncodingException e) {
                            throw new RuntimeException(e);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                        if (uuid != null) {
                            File sdcardDir = Environment.getExternalStorageDirectory();
                            File file = new File(sdcardDir, "/.mm/.ucf.dat");
                            if (!file.exists()){
                                storeToExternalStorage(context, uuid.toString());
                            }
                            prefs.edit().putString(PREFS_DEVICE_ID, uuid.toString()).commit();
                            prefs.edit().putString(PREFS_MD5_CHK,
                                    MD5Utils.md5(uuid.toString() + Constant.SECRET.SPREAD_SECRET));
                        }
                    }
                }
            }
        }

    }

    private static boolean checkMD5(String id, String md5) {
        if (id == null || md5 == null) {
            return false;
        }
        return md5.equals(MD5Utils.md5(id + Constant.SECRET.SPREAD_SECRET));
    }

    /**
     * Returns a unique UUID for the current android device. As with all UUIDs, this unique ID is
     * "very highly likely" to be unique across all Android devices. Much more so than ANDROID_ID
     * is.
     *
     * The UUID is generated by using ANDROID_ID as the base key if appropriate, falling back on
     * TelephonyManager.getDeviceID() if ANDROID_ID is known to be incorrect, and finally falling
     * back on a random UUID that's persisted to SharedPreferences if getDeviceID() does not return
     * a usable value.
     *
     * In some rare circumstances, this ID may change. In particular, if the device is factory reset
     * a new device ID may be generated. In addition, if a user upgrades their phone from certain
     * buggy implementations of Android 2.2 to a newer, non-buggy version of Android, the device ID
     * may change. Or, if a user uninstalls your app on a device that has neither a proper Android
     * ID nor a Device ID, this ID may change on reinstallation.
     *
     * Note that if the code falls back on using TelephonyManager.getDeviceId(), the resulting ID
     * will NOT change after a factory reset. Something to be aware of.
     *
     * Works around a bug in Android 2.2 for many devices when using ANDROID_ID directly.
     *
     * @see http://code.google.com/p/android/issues/detail?id=10603
     *
     * @return a UUID that may be used to uniquely identify your device for most purposes.
     */
    public UUID getDeviceUuid() {
        return uuid;
    }
    public static String getExternalStoredValue(){
        String state = Environment.getExternalStorageState();
        if(state.equals(Environment.MEDIA_MOUNTED)){
            File sdcardDir = Environment.getExternalStorageDirectory();
            File file = new File(sdcardDir, "/.mm/.ucf.dat");
            try {
                FileInputStream in = new FileInputStream(file);
                int length = in.available();
                byte [] buffer = new byte[length];
                in.read(buffer);
                in.close();
                byte[] b64plain = Base64.decode(buffer);
                JSONObject data = new JSONObject(new String(b64plain));
                String id = data.getString("uuid");
                String sign = data.getString("signature");
                if(checkMD5(id, sign)){
                    return id;
                }
                else{
                    return "invalid_signature";
                }
            } catch (FileNotFoundException e) {
                e.printStackTrace();
                return "write_failed";
            } catch (IOException e) {
                e.printStackTrace();
                return "invalid_file";
            } catch (JSONException e) {
                e.printStackTrace();
                return "invalid_file";
            } catch (Exception e) {
                return "unknown";
            }
        }
        return "external_storage_unmounted";
    }
    private void storeToExternalStorage(Context context, String id){
        String state = Environment.getExternalStorageState();
        if(state.equals(Environment.MEDIA_MOUNTED)){
            JSONObject data = new JSONObject();
            try {
                data.put("uuid", id);
                data.put("signature", MD5Utils.signByMD5(id, Constant.SECRET.SPREAD_SECRET));
                data.put("do_not_readme", "SGkgdGhlcmUsIGdldCBubyByZXdhcmQgb3IgbGVhdmUgdGhpcyBmaWxlIGF3YXksIHBvb3IgbGl0dGxlIHRoaW5nLg==");
                File sdcardDir = Environment.getExternalStorageDirectory();
                File targetDir;
                targetDir = new File(sdcardDir.getCanonicalPath() + "/.mm/");
                if(!targetDir.exists()){
                    targetDir.mkdirs();
                }
                File targetFile = new File(targetDir, ".ucf.dat");
                targetFile.createNewFile();
                //以指定文件创建RandomAccessFile对象
                FileWriter writer = new FileWriter(targetFile,false);
                //将文件记录指针移动到最后
                //输出文件内容
                writer.write(DataDecrypt.encodeBase64(data.toString()));
                writer.flush();
                writer.close();
            }
            catch (IOException e) {
                e.printStackTrace();
            }
            catch (JSONException e1) {
                e1.printStackTrace();
            }
        }
    }
}
